# Kong API 日誌處理管道配置
# Logstash configuration for Kong API Gateway logs

input {
  http {
    port => 8080
    codec => json
    response_headers => {
      "Access-Control-Allow-Origin" => "*"
      "Access-Control-Allow-Methods" => "POST, GET, OPTIONS"
      "Access-Control-Allow-Headers" => "Content-Type"
    }
  }
}

filter {
  # 解析 Kong 日誌時間戳
  if [started_at] {
    date {
      match => [ "started_at", "UNIX_MS" ]
      target => "@timestamp"
    }
  }

  # 計算響應時間指標
  if [latencies] {
    # 安全地提取延遲數據 - 檢查非空且為數字
    if [latencies][request] and [latencies][request] != "" and [latencies][request] != "null" {
      ruby {
        code => "
          val = event.get('[latencies][request]')
          if val.is_a?(Numeric) and val >= 0
            event.set('total_latency', val.to_i)
          end
        "
      }
    }

    if [latencies][proxy] and [latencies][proxy] != "" and [latencies][proxy] != "null" {
      ruby {
        code => "
          val = event.get('[latencies][proxy]')
          if val.is_a?(Numeric) and val >= 0
            event.set('proxy_latency', val.to_i)
          end
        "
      }
    }

    if [latencies][kong] and [latencies][kong] != "" and [latencies][kong] != "null" {
      ruby {
        code => "
          val = event.get('[latencies][kong]')
          if val.is_a?(Numeric) and val >= 0
            event.set('kong_latency', val.to_i)
          end
        "
      }
    }
  }

  # 提取 HTTP 方法和狀態碼
  if [request] and [request][method] {
    mutate {
      add_field => { "http_method" => "%{[request][method]}" }
    }
  }
  
  if [response] and [response][status] and [response][status] != "" and [response][status] != "null" {
    ruby {
      code => "
        val = event.get('[response][status]')
        if val.is_a?(Numeric) and val > 0
          event.set('http_status', val.to_i)
        end
      "
    }

    # 分類響應狀態
    if [http_status] >= 200 and [http_status] < 300 {
      mutate { add_field => { "response_category" => "success" } }
    } else if [http_status] >= 300 and [http_status] < 400 {
      mutate { add_field => { "response_category" => "redirect" } }
    } else if [http_status] >= 400 and [http_status] < 500 {
      mutate { add_field => { "response_category" => "client_error" } }
    } else if [http_status] >= 500 {
      mutate { add_field => { "response_category" => "server_error" } }
    }
  }

  # 提取服務和路由資訊
  if [service] and [service][name] {
    mutate {
      add_field => { "service_name" => "%{[service][name]}" }
    }
  }
  
  if [route] and [route][name] {
    mutate {
      add_field => { "route_name" => "%{[route][name]}" }
    }
  }

  # 提取用戶端 IP 並進行 GeoIP 查詢
  if [client_ip] {
    mutate {
      add_field => { "client_address" => "%{[client_ip]}" }
    }

    # GeoIP 地理位置查詢
    geoip {
      source => "client_address"
      target => "geoip"
      fields => ["city_name", "country_name", "country_code2", "region_name", "location", "timezone"]
    }
  }

  # 提取並解析 User-Agent
  if [request] and [request][headers] and [request][headers][user-agent] {
    mutate {
      add_field => { "user_agent" => "%{[request][headers][user-agent]}" }
    }

    # User-Agent 解析
    useragent {
      source => "user_agent"
      target => "user_agent_parsed"
    }
  }

  # 計算請求大小
  if [request] and [request][size] and [request][size] != "" and [request][size] != "null" {
    ruby {
      code => "
        val = event.get('[request][size]')
        if val.is_a?(Numeric) and val >= 0
          event.set('request_size', val.to_i)
        end
      "
    }
  }

  # 計算回應大小
  if [response] and [response][size] and [response][size] != "" and [response][size] != "null" {
    ruby {
      code => "
        val = event.get('[response][size]')
        if val.is_a?(Numeric) and val >= 0
          event.set('response_size', val.to_i)
        end
      "
    }
  }

  # 計算延遲統計和效能指標
  if [total_latency] {
    ruby {
      code => "
        total = event.get('total_latency').to_f

        # 延遲分類
        if total <= 100
          event.set('latency_category', 'fast')
        elsif total <= 500
          event.set('latency_category', 'medium')
        elsif total <= 1000
          event.set('latency_category', 'slow')
        else
          event.set('latency_category', 'very_slow')
        end

        # 效能分數 (0-100, 100為最佳)
        score = [100 - (total / 10), 0].max.to_i
        event.set('performance_score', score)
      "
    }
  }

  # SLA指標計算
  if [http_status] {
    ruby {
      code => "
        status = event.get('http_status')
        total_latency = event.get('total_latency') || 0

        # SLA可用性 (非5xx錯誤視為可用)
        event.set('sla_available', status < 500)

        # SLA效能 (響應時間 < 2000ms)
        event.set('sla_performance', total_latency < 2000)

        # 綜合SLA達成
        event.set('sla_met', status < 500 && total_latency < 2000)
      "
    }
  }

  # 添加處理時間戳
  mutate {
    add_field => { "processed_at" => "%{@timestamp}" }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "kong-api-logs-%{+YYYY.MM.dd}"
    template_name => "kong-logs"
    template => "/usr/share/logstash/templates/kong-template.json"
    template_overwrite => true
  }

  # 除錯輸出 (可在開發時啟用)
  # stdout { 
  #   codec => rubydebug 
  # }
}